// Copyright (C) 2025 ≈Åukasz 'activey' Grabski
// 
// This file is part of RasterFlow.
// 
// RasterFlow is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// RasterFlow is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with RasterFlow.  If not, see <https://www.gnu.org/licenses/>.

#include "config.h"
#include "gmic_runner.h"
#include <glib/gi18n-lib.h>
#include <gegl.h>
#include <gegl-plugin.h>
#include <math.h>
#include <stdio.h>
#include <gmic_libc.h>

#ifdef GEGL_PROPERTIES
{{for gegl_enum in filter.gegl_enums}}
{{gegl_enum}}

{{end}}

{{for parameter in filter.gegl_parameters}}
{{parameter}}
{{end}}
#else

#ifdef WITH_AUX
#define GEGL_OP_COMPOSER
#else
#define GEGL_OP_FILTER
#endif

#define GEGL_OP_NAME     gmic_{{filter.command}}
#define GEGL_OP_C_SOURCE gmic_{{filter.command}}.c

#include "gegl-op.h"

void gmic_run_rgba_float(float *data, int width, int height, const char *command);

static void prepare (GeglOperation *operation)
{
    const Babl *fmt = babl_format("R'G'B'A float");
    gegl_operation_set_format(operation, "input",  fmt);
    gegl_operation_set_format(operation, "output", fmt);

#ifdef WITH_AUX
    gegl_operation_set_format(operation, "aux",  fmt);
#endif
}

char *gegl_color_to_rgba(GeglColor *color, bool include_alpha)
{
    double r, g, b, a;
    gegl_color_get_rgba(color, &r, &g, &b, &a);

    int Ri = (int)(r * 255.0 + 0.5);
    int Gi = (int)(g * 255.0 + 0.5);
    int Bi = (int)(b * 255.0 + 0.5);
    int Ai = (int)(a * 255.0 + 0.5);

    char *out = g_malloc(24);

    if (include_alpha)
        sprintf(out, "%d,%d,%d,%d", Ri, Gi, Bi, Ai);
    else
        sprintf(out, "%d,%d,%d", Ri, Gi, Bi);

    return out;
}

static char* properties_string(GeglProperties *props) {
    {{if filter.has_parameters}}
    char *out = NULL;
    asprintf(&out, "{{filter.gegl_parameters_format}}", 
      {{for param_name in filter.gegl_parameters_names}}
      {{param_name}}
      {{end}}
    );
    return out;
    {{else}}
    return "";
    {{end}}
}

static gboolean
process (GeglOperation *operation,
         GeglBuffer    *input,
#ifdef WITH_AUX
         GeglBuffer    *aux,
#endif
         GeglBuffer    *output,
         const GeglRectangle *roi,
         gint level)
{
    
    GeglProperties *props = GEGL_PROPERTIES(operation);

    char full_cmd[2048];
    snprintf(full_cmd, sizeof(full_cmd), "%s %s gui_merge_layers", "{{filter.command}}", properties_string(props));
    return gmic_process_buffer(
        input, 
#ifdef WITH_AUX
        aux, 
#else
        NULL,
#endif 
        output, 
        roi, 
        level, 
        full_cmd
    );
}

static GeglRectangle
get_cached_region (GeglOperation *operation,
                   const GeglRectangle *roi)
{
    GeglRectangle full =
        *gegl_operation_source_get_bounding_box (operation, "input");
    return full;
}

static GeglRectangle
get_required_for_output (GeglOperation       *operation,
                         const gchar         *input_pad,
                         const GeglRectangle *roi)
{
  GeglRectangle result = *gegl_operation_source_get_bounding_box (operation, "input");
  if (gegl_rectangle_is_infinite_plane (&result))
    return *roi;

  return result;
}

static GeglRectangle
get_bounding_box (GeglOperation *op)
{
    const GeglRectangle *src =
        gegl_operation_source_get_bounding_box(op, "input");
    return src ? *src : gegl_rectangle_infinite_plane();
}

static void
gegl_op_class_init (GeglOpClass *klass)
{
  GeglOperationClass       *operation_class;
#ifdef WITH_AUX
  GeglOperationComposerClass *filter_class;
#else
  GeglOperationFilterClass *filter_class;
#endif

  operation_class = GEGL_OPERATION_CLASS (klass);
#ifdef WITH_AUX
  filter_class    = GEGL_OPERATION_COMPOSER_CLASS (klass);
#else
  filter_class    = GEGL_OPERATION_FILTER_CLASS (klass);
#endif

  filter_class->process = process;
  operation_class->prepare = prepare;
  operation_class->threaded = FALSE;
  operation_class->get_cached_region = get_cached_region;
  operation_class->get_required_for_output = get_required_for_output;
  operation_class->get_bounding_box = get_bounding_box;
  
  gegl_operation_class_set_keys (operation_class,
    "name",        "gmic:{{filter.command}}",
    "title",       _("{{filter.name}}"),
    "categories",  "{{filter.normalized_category_name}}",
    "reference-hash", "gmic_{{filter.command}}",
{{if filter.has_description }}
    "description", _("{{filter.description}}"),
{{end}}
    "gimp:menu-path", "<Image>/Filters/G'MIC GEGL/",
    "gimp:menu-label", _("{{filter.name}}"),
    NULL);
}

#endif
